package network.narrative.auction.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import network.narrative.auction.domain.Auction;
import network.narrative.auction.domain.BidResult;
import network.narrative.auction.domain.User;

@Service
public class Auctions implements Selling {

	private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);

	// TODO full production system this would be read/written from/to db via JPA in transactions
	private Map<Integer, Auction> auctions = new ConcurrentHashMap<Integer, Auction>();

	// TODO key column would be generated by JPA
	private AtomicInteger nextAuctionId = new AtomicInteger(0);

	// this was used instead of AtomicInteger above to validate junit test would report race condition
	//int next = 1;

	@Override
	public void createListing(Auction auction) {
		int id = nextAuctionId.incrementAndGet();
		auction.setId(id);
		auctions.put(id, auction);
	}

	@Override
	public List<Auction> getActiveListings() {
		ArrayList<Auction> activeListings = new ArrayList<Auction>();

		// TODO again, a full production system would read this from the db in a transaction
		for (Auction auction : auctions.values()) {
			if (auction.isActive()) {
				activeListings.add(auction);
			}
		}

		return activeListings;
	}

	@Override
	public List<Auction> getAllListings() {
		ArrayList<Auction> allListings = new ArrayList<Auction>();

		// TODO again, a full production system would read this from the db in a transaction
		for (Auction auction : auctions.values()) {
			allListings.add(auction);
		}

		return allListings;
	}

	@Override
	public void start(Auction auction) {
		// TODO this would be called from the UI after seller creates the listing and is ready to begin auction
		// TODO add validation logic, and throw custom checked exception if it fails
		auction.setActive(true);

		ScheduledFuture<?> countdown = scheduler.schedule(new Runnable() {
			@Override
			public void run() {
				// end the auction after 1 minute
				System.out.println("ending auction " + auction.toString());
				auction.setActive(false);
			}
		}, 1, TimeUnit.MINUTES);
	}

	@Override
	@Async
	public CompletableFuture<BidResult> placeBid(Integer auctionId, Double bid, User bidder) {
		BidResult result = new BidResult();
		Auction auction = auctions.get(auctionId);

		// TODO a full production system would check against database in an atomic transaction
		if (auction.isActive()) {
			if (bid > auction.getCurrentBid()) {
				auction.setCurrentBid(bid);
				auction.setHighestBidder(bidder);
				result.setSucceeded(true);
				result.setMessage("BID ACCEPTED");
			} else if (bid == auction.getCurrentBid()) {
				result.setSucceeded(false);
				result.setMessage("PLEASE ENTER A BID > " + auction.getCurrentBid());
			} else {
				result.setSucceeded(false);
				result.setMessage("OUT BID");
			}
		} else {
			result.setSucceeded(false);
			result.setMessage("AUCTION ENDED");
		}

		return CompletableFuture.completedFuture(result);
	}

}
